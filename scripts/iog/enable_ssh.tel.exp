#!/usr/bin/expect

set host "none"
set port 23
set pass "none"

if {0 == $argc} {
	puts "Usage: snlogin.exp <host> \[password\]"
	exit 0
}
set host [lindex $argv 0]

# If no password on stdin, prompt user for it
if {2 == $argc} {
	set pass [lindex $argv 1]
} else {
	# Turn off echoing, but leave newlines on.  That looks better.
	# Note that the terminal is left in cooked mode, so people can still use backspace
	exec stty -echo echonl <@stdin

	puts -nonewline stdout "Password: "
	flush stdout

	gets stdin pass

	# Reset the terminal
	exec stty echo -echonl <@stdin
}

proc err {msg} {
	puts $msg
	exit 1
}

proc sendc {cmd} {
	global spawn_id
	after 100
	send "$cmd\n"
}

set timeout 10

spawn telnet $host $port

expect {
	"login: "           {sendc "jbmgatew"}
	"Unable to connect" {err "\nAre you sure you have the right host?"}
	timeout             {err "Timed out waiting for login"}
}
expect {
	"Password: " {sendc "$pass"}
	timeout      {err "Timed out waiting for rlcuser password prompt"}
}
expect {
	"\]$ "            {sendc "su -"}
	"Login incorrect" {err "\n\nPlease try a different password"}
	timeout           {err "Timed out waiting for rlcuser shell prompt"}
}
expect {
	"Password: " {sendc "$pass"}
	timeout      {err "Timed out waiting for root password prompt"}
}
expect {
	"\]# "               {sendc "sed -i 's/^\\(PermitRootLogin\\).*$/\\1 yes/' /etc/ssh/sshd_config"}
	"incorrect password" {err "\nroot appears to be using a different password"}
	timeout              {err "Timed out waiting for root shell prompt"}
}
expect {
	"\]# "  {sendc "service sshd restart"}
	timeout {err "Timed out waiting for root shell prompt"}
}
expect "\]# "
close
puts ""
